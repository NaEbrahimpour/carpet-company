
    
package carpetcompany;

import java.io.*; 
import java.util.*; 
import java.lang.*; 

public class CarpetCompany {
    
    static Integer w[][]=new Integer[300][400];
    static int vcolor[]=new int[120000];
    
    public static void main(String[] args) {
        int C[][]=new int[400][400];
        int A[][]=new int[400][400];
        int B[][]=new int[400][400];
        addZeor(A);
        addZeor(B);
        addZeor(C);
        strassen(100, A, B, C);
        //graphColoring(n, vertic);
    }
static void strassen(int n,int A[][],int B[][],int C[][]){
    if(n==2){
        C[0][0]=(A[0][0]*B[0][0]) + (A[0][1]*B[1][0]);
        C[0][1]=(A[0][0]*B[0][1]) + (A[0][1]*B[1][1]);
        C[1][0]=(A[1][0]*B[0][0]) + (A[1][1]*B[1][0]);
        C[1][1]=(A[1][0]*B[0][1]) + (A[1][1]*B[1][1]);
    }
    else {
        int A11[][]=new int[n/2][n/2];
        int A12[][]=new int[n/2][n/2];
        int A21[][]=new int[n/2][n/2];
        int A22[][]=new int[n/2][n/2];
        int B11[][]=new int[n/2][n/2];
        int B12[][]=new int[n/2][n/2];
        int B21[][]=new int[n/2][n/2];
        int B22[][]=new int[n/2][n/2];
        int M1[][]=new int[n/2][n/2],M2[][]=new int[n/2][n/2],M3[][]=new int[n/2][n/2]
                ,M4[][]=new int[n/2][n/2],M5[][]=new int[n/2][n/2],M6[][]=new int[n/2][n/2]
                ,M7[][]=new int[n/2][n/2],C00[][]=new int[n][n],C01[][]=new int[n][n],
                C10[][]=new int[n][n],C11[][]=new int[n][n],i,j;
        for(i=0 ; i<n/2 ; i++)
            for(j=0 ; j<n/2 ; j++){
                A11[i][j]=A[i][j];
                A12[i][j]=A[i][j+n/2];
                B11[i][j]=B[i][j];
                B12[i][j]=B[i][j+n/2];
                A21[i][j]=A[i+n/2][j];
                A22[i][j]=A[i+n/2][j+n/2];
                B21[i][j]=B[i+n/2][j];
                B22[i][j]=B[i+n/2][j+n/2];
            }
        strassen(n/2, add(n/2,A11,A22,true), add(n/2,B11,B22,true), M1);
        strassen(n/2,add(n/2, A21, A22,true), B11 , M2);
        strassen(n/2, A11, add(n/2,B12,B22,false), M3);
        strassen(n/2, A22, add(n/2, B21, B11, false), M4);
        strassen(n/2,add(n/2, A11, A12, true) , B22, M5);
        strassen(n/2, add(n/2, A21, A11, false), add(n/2, B11, B12, true), M6);
        strassen(n/2, add(n/2, A12, A22, false), add(n/2, B21, B22, true), M7);
        C00=add(M1.length,add(M1.length, M1, M4, true),add(M5.length, M5, M7, true),false);
        C01=add(M3.length, M3, M5, true);
        C10=add(M2.length,M2, M4, true);
        C11=add(M1.length,add(M1.length, M1, M3, true),add(M2.length, M2, M6, true),false);
        for(i=0 ; i<C00.length ; i++)
            for(j=0 ; j<C00.length ; j++){
                C[i][j]=C00[i][j];
                C[i][j+n/2]=C01[i][j];
                C[i+n/2][j]=C10[i][j];
                C[i+n/2][j+n/2]=C11[i][j];
            }
    }
}
static int[][] add(int n,int A[][],int B[][],boolean addOrsub){
    int C[][]=new int[n][n];
    for(int i=0 ; i<n ; i++)
        for(int j=0 ; j<n ; j++)
            if(addOrsub) C[i][j]=A[i][j]+B[i][j];
            else C[i][j]=A[i][j]-B[i][j];
    return C;
}
static int minColor(int n){
    System.out.println("Enter neighbour regions");
    java.util.Scanner in=new java.util.Scanner(System.in);
    String input=in.nextLine();
    String input2[]=new String[n];
    input2=input.split(",");
    int i,j,k=0;
    for(i=0 ; i<n ;i++)
        for(j=0 ; j<n ; j++)
            w[i][j]=0;        
    for(i=0 ; i<n ; i++)        
        w[Integer.parseInt(input2[k++])-1][Integer.parseInt(input2[k++])-1]=1;   
    ////finding min num of colors////
    int color;
    for(i=0 ; i<n ; i++)
        vcolor[i]=0;
    vcolor[0]=1;
    for(i=1 ; i<n ; i++){
        color=2;
        for(j=0 ; j<i ; j++)
            if(w[j][i]==1)
                if(vcolor[j]==color)
                    color++;
                else vcolor[i]=color;
    }
    for(i=0 ; i<n ; i++)
        if(vcolor[i] == 0) break;
    return i-1;
}
static void graphColoring(int n,int vertic){
    int i,minColor=minColor(n);
    if(promising(vertic))
        if(vertic == n-1)
            for(i=0 ; i<n ; i++)
                System.out.println(vcolor[i]+" ");
        else for(i=1 ; i<minColor ; i++){
                vcolor[vertic+1]= i;
                graphColoring(n,vertic+1);
             }
}
static boolean promising(int i){
    int j=1;
    boolean swich=true;
    while (j<i && swich) {
        if( (w[i][j]==1) && (vcolor[i]==vcolor[j]))
            swich=false;
        j++;
    }
    return swich;
}
static void addZeor(int matrix[][]){
    for(int i=300 ; i<400 ; i++)
        for(int j=0 ; j<400 ; j++)
            matrix[i][j]=0;
} 

////sequence alignment////////

// function to find out the minimum penalty 
static void getMinimumPenalty(String x, String y, int pxy, int pgap) 
{ 
    int i, j; // intialising variables 
    int m = x.length(); // length of gene1 
    int n = y.length(); // length of gene2 
    // table for storing optimal substructure answers 
    int dp[][] = new int[n + m + 1][n + m + 1]; 
    for (int[] x1 : dp) 
    Arrays.fill(x1, 0); 
    // intialising the table  
    for (i = 0; i <= (n + m); i++) 
    { 
        dp[i][0] = i * pgap; 
        dp[0][i] = i * pgap; 
    }  
    // calcuting the minimum penalty 
    for (i = 1; i <= m; i++) 
    { 
        for (j = 1; j <= n; j++) 
        { 
            if (x.charAt(i - 1) == y.charAt(j - 1)) 
            { 
                dp[i][j] = dp[i - 1][j - 1]; 
            } 
            else
            { 
                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1] + pxy , dp[i - 1][j] + pgap) , dp[i][j - 1] + pgap ); 
            } 
        } 
    } 
    // Reconstructing the solution 
    int l = n + m; // maximum possible length       
    i = m; j = n;       
    int xpos = l; 
    int ypos = l;   
    // Final answers for the respective strings 
    int xans[] = new int[l + 1];  
    int yans[] = new int[l + 1];       
    while ( !(i == 0 || j == 0)) 
    { 
        if (x.charAt(i - 1) == y.charAt(j - 1)) 
        { 
            xans[xpos--] = (int)x.charAt(i - 1); 
            yans[ypos--] = (int)y.charAt(j - 1); 
            i--; j--; 
        } 
        else if (dp[i - 1][j - 1] + pxy == dp[i][j]) 
        { 
            xans[xpos--] = (int)x.charAt(i - 1); 
            yans[ypos--] = (int)y.charAt(j - 1); 
            i--; j--; 
        } 
        else if (dp[i - 1][j] + pgap == dp[i][j]) 
        { 
            xans[xpos--] = (int)x.charAt(i - 1); 
            yans[ypos--] = (int)'_'; 
            i--; 
        } 
        else if (dp[i][j - 1] + pgap == dp[i][j]) 
        { 
            xans[xpos--] = (int)'_'; 
            yans[ypos--] = (int)y.charAt(j - 1); 
            j--; 
        } 
    } 
    while (xpos > 0) 
    { 
        if (i > 0) xans[xpos--] = (int)x.charAt(--i); 
        else xans[xpos--] = (int)'_'; 
    } 
    while (ypos > 0) 
    { 
        if (j > 0) yans[ypos--] = (int)y.charAt(--j); 
        else yans[ypos--] = (int)'_'; 
    }   
    // Since we have assumed the answer to be n+m long,we need to remove the extra gaps in the starting id
    //represents the index from which the arrays xans, yans are useful 
    int id = 1; 
    for (i = l; i >= 1; i--) 
    { 
        if ((char)yans[i] == '_' &&  
            (char)xans[i] == '_') 
        { 
            id = i + 1; 
            break; 
        } 
    }   
    // Printing the final answer 
    System.out.print("Minimum Penalty in " + "aligning the genes = "); 
    System.out.print(dp[m][n] + "\n"); 
    System.out.println("The aligned genes are :"); 
    for (i = id; i <= l; i++) 
    { 
        System.out.print((char)xans[i]); 
    } 
    System.out.print("\n"); 
    for (i = id; i <= l; i++) 
    { 
        System.out.print((char)yans[i]); 
    } 
    return; 
}

//////////////sequence alignment////////////

static void dijkstra(int n,int w[][],LinkedList<Integer> setOfEdges){
    int i,vnear=0,edge,min;
    int touch[]=new int[n],length[]=new int[n];
    for(i=1 ; i<n ; i++){
        touch[i]=0;
        length[i]=w[0][i];
    }
    for(int j=0 ; j<n-1 ; j++){ ///repeat( n-1 times )
        min=n*n;///min=endless
        for(i=1 ; i<n ; i++){
            min=length[i];
            vnear=i;
        }
        edge=w[touch[vnear]][vnear];
        setOfEdges.addLast(edge);
        for(i=  1 ; i<n ; i++)
            if(length[vnear] + w[vnear][i] < length[i] ){
                length[i]=length[vnear] + w[vnear][i];
                touch[i]=vnear;
            }
        length[vnear]=-1;
    }
    
}

}
