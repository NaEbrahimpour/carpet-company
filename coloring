
package carpet_company;

public class Coloring {
    static Integer w[][]=new Integer[4][4];
    static int vcolor[]=new int[16];
    static int V=4;
     public static void main(String[] args) {
        
        int m = minColor(4); // Number of colors 
        graphColoring(w, m  ); 
         System.out.println(m);
         for(int i=0;i<4;i++){
             for(int j=0;j<4;j++)
                System.out.print(w[i][j]);
             System.out.println();
         }
     }
    
    static int minColor(int n){
    System.out.println("Enter neighbour regions");
    java.util.Scanner in=new java.util.Scanner(System.in);
    String input=in.nextLine();
    String input2[]=new String[n];
    input2=input.split(",");
    int i,j,k=0;
    for(i=0 ; i<n ;i++)
        for(j=0 ; j<n ; j++)
            w[i][j]=0;        
    for(i=0 ; i<=n ; i++)        
        w[Integer.parseInt(input2[k++])-1][Integer.parseInt(input2[k++])-1]=1;   
    ////finding min num of colors////
    int color;
    for(i=0 ; i<n ; i++)
        vcolor[i]=0;
    vcolor[0]=1;
    for(i=1 ; i<n ; i++){
        color=2;
        for(j=0 ; j<i ; j++)
            if(w[j][i]==1)
                if(vcolor[j]==color)
                    color++;
                else vcolor[i]=color;
    }
    for(i=0 ; i<n ; i++)
        if(vcolor[i] == 0) break;
    return i-1;
}
    

    ///////////////////////////////////////////////////////////////////
    static boolean isSafe(int v, Integer graph[][], int color[], 
                   int c) 
    { 
        for (int i = 0; i < V; i++) 
            if (graph[v][i] == 1 && c == color[i]) 
                return false; 
        return true; 
    } 
  
    /* A recursive utility function to solve m 
       coloring  problem */
    static boolean graphColoringUtil(Integer graph[][], int m, 
                              int color[], int v) 
    { 
        
        /* base case: If all vertices are assigned 
           a color then return true */
        if (v == V) 
            return true; 
  
        /* Consider this vertex v and try different 
           colors */
        for (int c = 1; c <= m; c++) 
        { 
            /* Check if assignment of color c to v 
               is fine*/
            if (isSafe(v, graph, color, c)) 
            { 
                color[v] = c; 
  
                /* recur to assign colors to rest 
                   of the vertices */
                if (graphColoringUtil(graph, m, 
                                      color, v + 1)) 
                    return true; 
  
                /* If assigning color c doesn't lead 
                   to a solution then remove it */
                color[v] = 0; 
            } 
        } 
  
        /* If no color can be assigned to this vertex 
           then return false */
        return false; 
    } 
  
    /* This function solves the m Coloring problem using 
       Backtracking. It mainly uses graphColoringUtil() 
       to solve the problem. It returns false if the m 
       colors cannot be assigned, otherwise return true 
       and  prints assignments of colors to all vertices. 
       Please note that there  may be more than one 
       solutions, this function prints one of the 
       feasible solutions.*/
    static boolean graphColoring(Integer graph[][], int m) 
    { 
        // Initialize all color values as 0. This 
        // initialization is needed correct functioning 
        // of isSafe() 
        vcolor = new int[V]; 
        for (int i = 0; i < V; i++) 
            vcolor[i] = 0; 
  
        // Call graphColoringUtil() for vertex 0 
        if (!graphColoringUtil(graph, m, vcolor, 0)) 
        { 
            System.out.println("Solution does not exist"); 
            return false; 
        } 
  
        // Print the solution 
        printSolution(vcolor); 
        return true; 
    } 
  
    /* A utility function to print solution */
    static void printSolution(int color[]) 
    { 
        System.out.println("Solution Exists: Following" + 
                           " are the assigned colors"); 
        for (int i = 0; i < V; i++) 
            System.out.print(" " + color[i] + " "); 
        System.out.println(); 
    } 
  
   /* static boolean isSafe(int i, Integer w[][], int vcolor[],int m,int n) 
    { 
        for (int p = 0; p < n; p++) 
            if (w[i][p] == 1 && m == vcolor[p]) 
                return false; 
        return true; 
    } 
    static boolean graphColoringUtil(Integer w[][], int m, int vcolor[], int i, int n) 
    { 
        if (i == n) 
            return true;   
        for (int c = 1; c <= m; c++) 
        { 
            if (isSafe(i, w, vcolor, c, n)) 
            { 
                vcolor[i] = c; 
  
                if (graphColoringUtil(w, m, vcolor, i + 1,n)) 
                    return true; 
                vcolor[i] = 0; 
            } 
        } 
        return false; 
    } 
    static boolean graphColoring(Integer w[][], int m , int n) 
    { 
        vcolor = new int[n]; 
        for (int i = 0; i < n; i++) 
            vcolor[i] = 0; 
        if (!graphColoringUtil(w, m, vcolor, 0, n)) 
        { 
            System.out.println("Solution does not exist"); 
            return false; 
        } 
        printSolution(vcolor , n); 
        return true; 
    }
    static void printSolution(int vcolor[] , int n) 
    { 
        System.out.println("Solution Exists: Following" +   " are the assigned colors"); 
        for (int i = 0; i <n ; i++) 
            System.out.print(" " + vcolor[i] + " "); 
        System.out.println(); 
    }  */      
}   
